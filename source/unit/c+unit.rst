C ++ unit testing  
=============================================
C ++ is mainly for testing each class, wings will automatically generate the driver code of each class and the corresponding GoogleTest code.

Naming rules
-----------------------

The file name corresponding to the driver generated by each class is: driver + class name.cc and .h , the name of the driver class is: Driver + ClassName ( class name ) , there are many operator overloaded functions in c ++ , in order to ensure the uniqueness of the function, The functions for the class are numbered from 0 , that is, Driver + function name + number.


Generate code
-----------------------

The corresponding test class code will be generated for each class in C ++ . As shown in below, Rectangle is the class under test and contains 3 member variables of type Point , int , std :: string, assuming Rectangle as the function parameter, the configuration of such object requires . 3 members variable assignment, WINGS automatically inserts a constructor in the source code for each class, the member variable assignment.

::

	class Rectangle
	{
	private:
		Point *m_point;
		int m_z;
		std::string name;
	public:
		Rectangle();
		int GetVolume();
		void PrintVolume(Rectangle *rect, int parm);
	public:
		Rectangle(Point *m_point, int m_z, std::string name, bool wings)
		{
			//LOGI("Rectangle::Rectangle");
			this->m_point = m_point;
			this->m_z = m_z;
			this->name = name;
		}
	};


For each driver class in below, a corresponding constructor will be generated to initialize the tested class, as shown in below :

::

	#include "Rectangle.h"
	#include "driver.h"
	class DriverRectangle {
	public:
	  DriverRectangle(Json::Value Root, int times);
	  ~DriverRectangle();
	  int DriverRectangleGetVolume0(int times);
	  void ReturnDriver_GetVolume0(int returnType);
	  int GetVolume0Times;
	  int DriverRectanglePrintVolume1(int times);
	  int PrintVolume1Times;
	private:
	  Rectangle *_Rectangle;
	};

::

	DriverRectangle::DriverRectangle(Json::Value Root, int times) {
	  Json::Value Rectangle_Root = Root["Rectangle" + to_string(times)];
	  int pointSize = 0;
	  Json::Value m_point_Root = Rectangle_Root["m_point"][pointSize];
	  /* m_x */
	  int _m_point_m_x = m_point_Root["m_x"].asInt();
	  /* m_y */
	  int _m_point_m_y = m_point_Root["m_y"].asInt();
	  Point *_m_point = new Point(_m_point_m_x, _m_point_m_y, false);
	  /* m_z */
	  int _m_z = Rectangle_Root["m_z"].asInt();
	  string _name = Rectangle_Root["name"].asString();
	  _Rectangle = new Rectangle(_m_point, _m_z, _name, false);
	}
	DriverRectangle::~DriverRectangle() {
	  if (_Rectangle != nullptr) {
		delete _Rectangle;
	  }
	}
	
	
In the driver class, a driver function is generated for each function. As shown in below :

::

	int DriverRectangle::DriverRectanglePrintVolume1(int times) {
	  PrintVolume1Times = times;
	  /* Root is the json object of the value file.PrintVolume1_Root is
	   * function.PrintVolume1 is json object.  */
	  const char *jsonFilePath = "drivervalue/Rectangle/PrintVolume1.json";
	  Json::Value Root;
	  Json::Reader _reader;
	  ifstream _ifs(jsonFilePath);
	  _reader.parse(_ifs, Root);
	  Json::Value PrintVolume1_Root = Root["PrintVolume1" + to_string(times)];
	  /*It is the 1 parameter: rect    PrintVolume1*/
	  int pointSize = 0;
	  Json::Value rect_Root = PrintVolume1_Root["rect"][pointSize];
	  int pointSize = 0;
	  Json::Value m_point_Root = rect_Root["m_point"][pointSize];
	  /* m_x */
	  int _rect_m_point_m_x = m_point_Root["m_x"].asInt();
	  /* m_y */
	  int _rect_m_point_m_y = m_point_Root["m_y"].asInt();
	  Point *_rect_m_point = new Point(_rect_m_point_m_x, _rect_m_point_m_y, false);
	  /* m_z */
	  int _rect_m_z = rect_Root["m_z"].asInt();
	  string _rect_name = rect_Root["name"].asString();
	  Rectangle *_rect = new Rectangle(_rect_m_point, _rect_m_z, _rect_name, false);
	  /*It is the 2 parameter: parm    PrintVolume1*/
	  int _parm = PrintVolume1_Root["parm"].asInt();
	  // The Function of Class    Call
	  _Rectangle->PrintVolume(_rect, _parm);
	  return 0;
	}

